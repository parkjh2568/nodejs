- 노드에서 모듈이란것은 어플리케이션을 이루는 기본 조각이라 할수있다.

모듈종류

- 기본 모듈, 확장 모듈로 나누어짐
- 단순히 js만을썼는지, C/C++등 다른언어도 포함개발했는지에 따라 일반모듈, 네이티브모듈로 나뉨
- 지금 현재 웹 어플을 위해서만 사용하기위해 설치했는지에따라 글로벌모듈, 로컬모듈로 나뉨


기본모듈과 확장모듈

- 기본 모듈은 노드를 설치하면 기본으로 설치되는 모듈로서 파일 입출력, 이벤트 관리, HTTP 프로토콜
관리 등에 관한 내용으로써 노드의 비동기 입출력 처리를 위한 기본적인 기능들을 제공하는 모듈입니다.
이에 비해 확장 모듈은 노드의 기능을 확장하기 위한 것으로써 좀 더 쉬운 HTTP 서버 생성, 기본 파일
입출력에서 제공하지 않는 기능 추가 등 노드를 확장하고 더 편리하게 사용하기 위한 모듈이라고 말할
수 있습니다. 또한 확장 모듈은 나중에 소개할 express와 같은 모듈들처럼 하나의 프레임워크로서 제공되기도 하며, 
mongodb를 사용하기 위한 mongoose나 mongolian처럼 다른 기술을 손쉽게 끌어와 사용할
수 있게 도와주는 역할을 하기도 합니다.


일반 모듈과 네이티브 모듈

- 일반 모듈과 네이티브 모듈은 개발 방법에 따라 나눌 수 있는 내용입니다. 
일반적으로 노드의 기본 모듈은 C/C++로 개발된 경우가 대부분이며 이렇게 네이티브 프로그래밍 언어인 
C/C++로 노드의 모듈을 개발한 경우 네이티브 모듈이라고 합니다. 
확장 모듈 또한 네이티브 모듈로 개발할 수 있으며,  .node라는 확장자를 가졌으면 네이티브 모듈로 컴파일된 것이라고 보면 됩니다. 
일반 모듈은 노드의 모듈 인터페이스를 통해 간단히 자바스크립트로 개발된 모듈입니다. 
만약 같은 기능을 수행하는 네이티브 모듈과 일반 모듈이 있다고 한다면 대체로 네이티브 모듈이 더 나은 성능을 보입니다.


글로벌 모듈과 로컬 모듈

- 기본 모듈을 포함하여 어디서든 사용할 수 있도록 설치한 확장 모듈을 글로벌 모듈이라고 한다면,
해당 어플리케이션에서만 사용하기위해 설치한 확장 모듈이나
개발자가 개발한 모듈을 로컬 모듈이라고 분류할 수 있습니다.
확장 모듈을 글로벌 모듈로 사용하려면 설치시 특별한옵션(-g)을 이용하면 됩니다.


복합 모듈

- 복합 모듈은 내부 모듈이나 데이터 파일, 템플릿, 테스트코드 등을 포함하는 모듈을 말합니다.
다양한 파일을 포함하기 때문에 모듈을 구성하는 단위가 폴더이며 내부적으로
폴더를 가질 수 있습니다. require() 메소드가 이런 폴더단위의 모듈을 인식하려면
index.js파일이나 package.json 파일중 하나가 반드시 있어야합니다.


모듈 식별자

- 노드의 모듈 이름으로는 확장자 없는 전체 경로를 사용합니다.
앞서 설명한 것처럼 모듈은 파일과 일대일로 대응하기때문에 .js나 .node라는 확장자를 가지지만
모듈을 불러들일 때는 파일 이름만 사용하면 되기 때문입니다.
모듈의 식별자는 크게 상대적 식별자와 절대적 식별자, 그리고 최상위 레벨 식별자 등 3가지가 있습니다.


상대적 식별자

- 상대적 식별자는 현재 위치를 기준으로 상대적인 기준에 있는 모듈을 찾는 식별자입니다.
유닉스 시스템의 상대 경로와 유사하다고 할 수 있겠으나, ./를 생략하면 현재 위치에서 모듈을 찾지 않으니 주의
require('./sample_moduel');


절대적 식별자

- 절대적 식별자도 마찬가지로 절대 위치를 기준으로 모듈을 찾는 식별자이며
유닉스 시스템의 절대경로와 비슷합니다.
require('/usr/local/node_modules/sample_module/sample_module');


최상위 레벨 식별자

- 아무것도 입력하지 않고 모듈 이름만 입력하면 최상위 식별자로 인식
설치된 전체 확장 모듈이나 기본 모듈중에서 해당 모듈 이름을 검색해서 로드합니다.
require('sample_module');

- 여기서 중요한점은 sample_module이라는 식별자를 찾는순서입니다.
만약 sample_module이라는 모듈이 기본모듈에서 찾을수 없는 모듈이면
상위 디렉토리를 차례대로 타맥하게 됩니다. 예를들면 다음과같은 순서로 탐색하게됩니다.
/home/goorm/example_project/node_modules/sample_moudle.js
/home/goorm/node_modules/sample_module.js
/home/node_modules/sample_module.js
/node_modules/sample_module.js


require() 메소드와 module.exports

- 모듈 개념에서 require() 메소드와 module.exports가 왜 중요한 것일까요?

- 먼저 클라이언트 측 자바스크립트와 비교를 해보겠습니다. 
웹 브라우저에서 HTML의 <script> 태그로 필요한 자바스크립트를 
연결하고 호출하게 되어 있습니다. 
다음의 코드는 HTML 파일이 자바스크립트를 로딩하는 예제입니다.

<!DOCTYPE html>
<html>
    <body>
        <script type="text/javascript" src="goorm1.js"></script>
    </body>
</html>

- 이렇게 html 스크립트를 통해 명시된 js파일들은 웹 브라우저에 의해 로딩
서로 참조하거나 호출 할 수 있습니다.

- 하지만 노드는 HTML을 사용하지 않으므로 서로 다른 js파일들이 서로 참조하고 호출하는 방법이 필요합니다.

- require() 메소드는 모듈 식별자인 module.exports를 통해서 모듈이 제공하는 함수나 객체등을 반환합니다.
만약 불러온 모듈이 다른 모듈이 있어야만 한다면 그 모듈도 같이 로드하도록 되어있고 이것이 노드 모듈화의 핵심입니다.

- 노드에서 하나의 js파일은 하나의 모듈이 될 수 있다는것을 알고있습니다. 이때 자바스크립트 파일 내부에서 
함수나 변수를 module.exports에 할당하면 파일 외부에서 접근할 수 있습니다.

- B.js는 js로 작성된 모듈입니다. 이 모듈은 name이라는 변수와 run(), stop()이라는 메소드를 가지고있습니다.
A.js는 이러한 모듈 B를 사용하고자 하는 js파일입니다. 이파일에서
moduleA라는 객체는 require()메소드를 통해 생성된 모듈 B의 인스턴스를
할당받습니다. B.js에서는 module.exports를 통해 run()과 stop()
메소드를 외부에서 사용할수 있도록 허용하고 있으므로 A.js에서 moduleB를
통해 run()과 stop()메소드를 호출하여도 동작하게 됩니다. 
다시 말해, 모듈을 사용하는 파일에서는 require()메소드로 다른 js파일을 불러와서
module.exports로 하용된 변수나 함수를 사용할 수 있습니다.
